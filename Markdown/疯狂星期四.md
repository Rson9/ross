# 疯狂星期四
- [ ] **简单的遍历问题**
## 题目描述
一个风平浪静的星期四，Oshwiciqwq 正在网上冲浪，突然收到了很多条消息！但他不喜欢KFC，所以他不想阅读那些包含"疯狂星期四"文学的诈骗消息。请你帮他筛选出来哪些信息包含了"疯狂星期四"文学。具体来讲，每条消息是由字母和数字组成的一个字符串。子串是字符串中任意个连续的字符组成的子序列。如果这个字符串在忽略字母大小写的情况下，同时存在五个子串，它们分别为 "kfc"、"crazy"、"thursday"、"vivo"、"50" 五个关键词，那么就认为这个消息包含了"疯狂星期四"文学。另外，这些子串可以重叠。比如，"kfcrazy" 可以看做同时存在 "kfc" 和 "crazy" 两个子串。

## 输入

第一行一个正整数 $T$（1 ≤ $T$ ≤ 100），表示消息的条数。

接下来 $T$ 行，每行一个由字母和数字组成的字符串 $s_i$（1 ≤ |si| ≤ 1000），表示第 $i$ 条消息。

## 输出

输出 $T$ 行，每行包含一个字符串。

对于第 $i$ 行，如果第 $i$ 条消息包含了"疯狂星期四"文学，那么输出 "Yes"。 否则，输出 "No"。
## test#1
| Input                        | Output |
| :--------------------------- | :----- |
| 3                            |        |
| KFC1crazy2THURSday3Viv04SO   | NO     |
| KFC1crazy2THURSday3VivO450   | YES    |
| 50vIVoakjhsbCrazykfcThursday | YES    |
- [This is my code](/%E7%96%AF%E7%8B%82%E6%98%9F%E6%9C%9F%E5%9B%9B.cpp)  
我的代码很菜，通过一个简单的遍历来进行求解没有什么算法可言。
现在来分析一下别人的代码。
1. 首先把所有的大写字母变成小写字母。
~~~c++
        for(auto&&i:s){
            if('A'<=i&&i<='Z') i+=0x20;
        }
~~~
分析一下，先创建一个指针$i$，从字符串的第一个元素开始遍历,如果当前字符是大写字母，那么增加0x20（10进制的32），变成小写字母。    
1. 遍历字符串，通过c里面的$strstr()$进行字符串查找。
 ~~~c++
        puts(strstr(s,"kfc")&&strstr(s,"vivo")&&strstr(s,"crazy")&&strstr(s,"50")&&strstr(s,"thursday")?"YES":"NO");
 ~~~
- 总结一下，非常完美，比我写的简洁多了，而且复杂度是一样的。但是通过这个**指针的遍历**是我没有见过的，需要学习。